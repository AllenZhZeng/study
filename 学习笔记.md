2019-11-22
----------

	

 1.面向对象性能比面向过程差
---
 
    因为类调用时需要实例化,开销比较大,比较消耗资源java是半编译语言,最终的执行代码并不是可以直接被CPU执行的二进制机械码
 2. JAVA语言的**特点**:
---  

 

 - 面向对象(封装,继承,多态)
 - 跨平台性(通过JVM实现)
 - 支持多线程
 

 - JVM JDK和JRE 
---
###   JAVA程序从源码到运行分3步
        .java--JDK中的javac命令-->.class(JVM可以理解的字节)--JVM-->机器可执行的二进制机器码

 - 3. JAVA 和 C++ 的区别
---
    

 - 都是面向对象语言(封装,继承,多态)
 - java不提供指针来直接访问内存,程序更安全
 - java类是单继承,C++是多继承,java接口可以多继承
 - java有自动内存管理机制,不需要手动释放内存

    
    4.重载和重写
---
    

 - 构造方法不能被重写(override),但是可以被重载(overload)
 - 重载:发生在同一个类中,方法名必须相同,参数 个数,类型,顺序 不同,方法返回值和访问修饰符可以不同
 - 重写:是子类对父类的可访问的方法进行重新编写,发生在子类中,方法名,参数列表必须相同,返回值范围小于等于父类,抛出的异常范围小于等于父类,访问修饰符范围大于等于父类.
 5.Java 面向对象编程三大特性: 封装 继承 多态
---
 - 封装:将一个对象的属性私有化,然后提供一些可以被外界访问的属性的方法.
 - 继承:在已存在的类的基础上新增一个新类,新类可以新增一些新的属性和方法:

        子类拥有父类的所有属性和方法,但是父类中的私有属性和方法 子类是无法访问的,只是拥有 
        子类可以拥有自己的属性和方法,即在父类的基础上进行拓展
        子类可以用自己的方式实现父类的方法
 

 - 多态:简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
 5.接口和抽象类的区别
---
- 接口的方法默认是public,所有方法在接口中不能有实现(java8开始可以有默认实现了),而抽象类可以有非抽象的方法.
- 接口中除了 static,final变量外不能有其他变量,而抽象类中则不一定.
- 接口是多实现,抽象类是单继承,接口本身可以通过extends关键字拓展多个接口
- 接口方法默认修饰符是public,抽象方法可以有public,protected,default(不能是private,抽象方法就是为了被重写的,所以不能是private)
- 从设计层面讲,抽象是对类的抽象,是一种模板设计,接口是是对行为的抽象,是一种行为的规范.
> PS:jdk1.8后，接口方法可以有方法体，需要用default或static修饰。实现类无需重新。当然default方法重写也是可以的。如果一个类实现多个接口，多个接口有相同default方法，则子类必须重写该方法.
关于抽象类
JDK 1.8以前，抽象类的方法默认访问权限为protected
JDK 1.8时，抽象类的方法默认访问权限变为default
关于接口
JDK 1.8以前，接口中的方法必须是public的
JDK 1.8时，接口中的方法可以是public的，也可以是default的
JDK 1.9时，接口中的方法可以是private的

6.hashCode和equals
---
- hashCode: hashCode()的作用就是获取哈希码,也称为散列码;它实际上就是返回一个int值.这个哈希码的作用就是确定该对象在哈希表中的位置.hashCode()定义在Object中,这意味着任何类都包含hashCode()函数.
- hashCode()与equals()的相关规定 :
> 如果两个对象相等那么它们的hashCode一定相等
> 两个对象相等,对两个对象分别调用equals()方法都返回true
> 两个对象有相同的hashCode值,它们也不一定是相等的
> **因此,equals方法覆盖过,hashCode方法也必须覆盖**
> hashCode()的默认行为是对堆上的对象产生独特值,如果没有重写hashCode(),则该class的两个对象无论如何都不会相等

7.为什么说Java中只有值传递
---
> 在调用函数时,传递给函数的是实参的地址的拷贝(如果实参是在栈中 则直接拷贝该值)

8.线程的基本状态
---

> 线程创建之后处于NEW(新建) 状态 , 调用start()过后开始运行,处于READY(可运行)状态,可运行状态的线程获得了cpu时间片(timelice)后就处于RUNNING(运行)状态.
> 当线程运行wait()方法过后,线程进入WAITING(等待)状态,进入等待状态的线程要通过其他线程的通知才能返回到运行状态,TIME_WAITING(超时等待)状态相当于在等待的基础上加了超时限制,比如通过 sleep(long millis) 或者 wait(long millis) 可以讲线程置于TIME_WAITING状态,当超时时间到达后,线程会返回到RUNNABLE状态.
> 当线程调用同步方法时,在没有获取到锁的情况下,线程将会进入到BLOCKED(阻塞)状态.
> 线程在执行Runnable的run()方法之后,将会进入到TERMINATED(终止)状态

9.final关键字
---

> final关键字主要用在三个地方: 变量,方法,类

 1. 对于final修饰的变量,如果是基础数据类型那么在初始化过后就不能改变其值了,如果是引用类型的变量,在初始化之后就不能改变其引用了
 2. 当final修饰类时,这个类不能被继承,类中的所有成员方法会被隐式的被指定为final方法
 3. 使用final修饰方法是防止任何继承类修改它的涵义.类中的所有private方法都隐式的指定为final
 
10.java中的异常处理
---

1.java异常类层次结构

> 

