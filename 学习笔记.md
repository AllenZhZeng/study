

	

 1.面向对象性能比面向过程差
---
 
    因为类调用时需要实例化,开销比较大,比较消耗资源java是半编译语言,最终的执行代码并不是可以直接被CPU执行的二进制机械码
 2. JAVA语言的**特点**:
---  

 

 - 面向对象(封装,继承,多态)
 - 跨平台性(通过JVM实现)
 - 支持多线程
 

 - JVM JDK和JRE 
---
###   JAVA程序从源码到运行分3步
        .java--JDK中的javac命令-->.class(JVM可以理解的字节)--JVM-->机器可执行的二进制机器码

 - 3. JAVA 和 C++ 的区别
---
    

 - 都是面向对象语言(封装,继承,多态)
 - java不提供指针来直接访问内存,程序更安全
 - java类是单继承,C++是多继承,java接口可以多继承
 - java有自动内存管理机制,不需要手动释放内存

    
    4.重载和重写
---
    

 - 构造方法不能被重写(override),但是可以被重载(overload)
 - 重载:发生在同一个类中,方法名必须相同,参数 个数,类型,顺序 不同,方法返回值和访问修饰符可以不同
 - 重写:是子类对父类的可访问的方法进行重新编写,发生在子类中,方法名,参数列表必须相同,返回值范围小于等于父类,抛出的异常范围小于等于父类,访问修饰符范围大于等于父类.
 5.Java 面向对象编程三大特性: 封装 继承 多态
---
 - 封装:将一个对象的属性私有化,然后提供一些可以被外界访问的属性的方法.
 - 继承:在已存在的类的基础上新增一个新类,新类可以新增一些新的属性和方法:

        子类拥有父类的所有属性和方法,但是父类中的私有属性和方法 子类是无法访问的,只是拥有 
        子类可以拥有自己的属性和方法,即在父类的基础上进行拓展
        子类可以用自己的方式实现父类的方法
 

 - 多态:简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
 5.接口和抽象类的区别
---
- 接口的方法默认是public,所有方法在接口中不能有实现(java8开始可以有默认实现了),而抽象类可以有非抽象的方法.
- 接口中除了 static,final变量外不能有其他变量,而抽象类中则不一定.
- 接口是多实现,抽象类是单继承,接口本身可以通过extends关键字拓展多个接口
- 接口方法默认修饰符是public,抽象方法可以有public,protected,default(不能是private,抽象方法就是为了被重写的,所以不能是private)
- 从设计层面讲,抽象是对类的抽象,是一种模板设计,接口是是对行为的抽象,是一种行为的规范.
> PS:jdk1.8后，接口方法可以有方法体，需要用default或static修饰。实现类无需重新。当然default方法重写也是可以的。如果一个类实现多个接口，多个接口有相同default方法，则子类必须重写该方法.
关于抽象类
JDK 1.8以前，抽象类的方法默认访问权限为protected
JDK 1.8时，抽象类的方法默认访问权限变为default
关于接口
JDK 1.8以前，接口中的方法必须是public的
JDK 1.8时，接口中的方法可以是public的，也可以是default的
JDK 1.9时，接口中的方法可以是private的

6.hashCode和equals
---
- hashCode: hashCode()的作用就是获取哈希码,也称为散列码;它实际上就是返回一个int值.这个哈希码的作用就是确定该对象在哈希表中的位置.hashCode()定义在Object中,这意味着任何类都包含hashCode()函数.
- hashCode()与equals()的相关规定 :
> 如果两个对象相等那么它们的hashCode一定相等
> 两个对象相等,对两个对象分别调用equals()方法都返回true
> 两个对象有相同的hashCode值,它们也不一定是相等的
> **因此,equals方法覆盖过,hashCode方法也必须覆盖**
> hashCode()的默认行为是对堆上的对象产生独特值,如果没有重写hashCode(),则该class的两个对象无论如何都不会相等

7.为什么说Java中只有值传递
---
> 在调用函数时,传递给函数的是实参的地址的拷贝(如果实参是在栈中 则直接拷贝该值)

8.线程的基本状态
---

> 线程创建之后处于NEW(新建) 状态 , 调用start()过后开始运行,处于READY(可运行)状态,可运行状态的线程获得了cpu时间片(timelice)后就处于RUNNING(运行)状态.
> 当线程运行wait()方法过后,线程进入WAITING(等待)状态,进入等待状态的线程要通过其他线程的通知才能返回到运行状态,TIME_WAITING(超时等待)状态相当于在等待的基础上加了超时限制,比如通过 sleep(long millis) 或者 wait(long millis) 可以讲线程置于TIME_WAITING状态,当超时时间到达后,线程会返回到RUNNABLE状态.
> 当线程调用同步方法时,在没有获取到锁的情况下,线程将会进入到BLOCKED(阻塞)状态.
> 线程在执行Runnable的run()方法之后,将会进入到TERMINATED(终止)状态

9.final关键字
---

> final关键字主要用在三个地方: 变量,方法,类

 1. 对于final修饰的变量,如果是基础数据类型那么在初始化过后就不能改变其值了,如果是引用类型的变量,在初始化之后就不能改变其引用了
 2. 当final修饰类时,这个类不能被继承,类中的所有成员方法会被隐式的被指定为final方法
 3. 使用final修饰方法是防止任何继承类修改它的涵义.类中的所有private方法都隐式的指定为final
 
10.java中的异常处理
---

1.java异常类层次结构

> 在java中所有的异常都有一个共同的祖先java,lang包中的Throwable类.  Throwable有2个重要的子类:Exception(异常)和ERROR(错误) ,二者都是java异常处理的重要子类,各自都有大量的子类

> ERROR:是程序无法处理的错误.

> EXCEPTION: 是程序本身可以处理的异常.

>  异常是能被程序本身处理的,而错误是程序无法处理的.

###**异常处理总结:**

 - **try块:** 用于捕获异常,后面可以接0~n个catch,如果没有catch块则必须有一个finally块
 - **catch块:** 用于处理捕获的异常
 - **finally块:** 无论是否捕获或处理异常,finally块里的语句都会被执行,如果try或者catch里有return,finally里的语句将会在return之前执行
 
**以下情况finally块的代码不会执行:**

    1.在finally的第一句代码发生异常.
    2.在前面的代码中用了System.exit(int).
    3.程序所在线程死亡
    4.关闭CPU

> 当try和finally里都有return时,在方法返回前  finally里的代码将会执行  并且finally里的return结果将会覆盖前面的return

11.IO流
---

###**有字节流为什么还要字符流**

> 字符流是java虚拟机由字节转换而来,问题就出在这个过程非常耗时,并且我们不知道编码类型的话就很容易出现乱码.所以,I/O流就干脆提供了一个直接操作字符的接口,方便我们平时对字符进行流操作.如果音频文件,图片等媒体文件用字节流比较好.如果涉及到字符的话用字符流比较好.

###**BIO,NIO,AIO的区别**

 - **BIO(Blocking I/O):**同步阻塞I/O模式, 数据的读取写入必须阻塞在一个线程内等待其完成.在活动连接数不是特别高(小于单机1000)的情况下,这种模型是不错的,可以让每个链接专注于自己的I/O 并且编程模型简单,也不用过多的考虑系统的过载,限流等问题.线程池本身就是一个天然的漏斗,可以缓冲一个系统处理不了的链接或请求,但是当面对十万甚至上百万级连接的问题时,传统的BIO模型是无能为力的.
 - **NIO(NEW I/O):** NIO是一种同步非阻塞的I/O模型,在java1.4中引入了nio框架,对应java.nio包,提供了Channel,Selector,Buffer等抽象,NIO中的N可以理解成 Non-blocking,不单纯是new.它支持面向缓冲,支持通道的I/O操作方法.NIO提供了与传统BIO模型中的`Socket`和`ServerSocket` 相对应的 `SocketChannel`和`ServerSocketChannel` 两种不同的套接字通道实现.两种通道都支持阻塞和非阻塞两种模式.阻塞模式使用就像传统中的支持一样,比较简单,但是行能和可靠性都不好; 非阻塞模式正好与之相反.对于低负载,低并发的应用程序,可以使用阻塞I/O来提升开发速率和更好的维护性.对于高负载 高并发的应用,应该使用NIO的非阻塞模式进行开发.
 - **AIO(Asynchronous I/O):** AIO也就是NIO2. 在java7中引入了NIO的改进版NIO2.他是异步非阻塞IO模型.异步IO是基于事件和回调机制实现的,也就是应用操作后会直接返回,不会堵塞在那里,当后台处理完成,操作系统会通知相应线程进行后续操作.AIO是异步IO的缩写,虽然NIO在网络操作中提供了非阻塞的方法,但是的IO行为还是同步的.

